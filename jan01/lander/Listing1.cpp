///////////////////////////////////////////////////////////////////////////////// Function:	AutoComputeWeights// Purpose:		Set the vertex weights based on closeness to bones// Arguments:	Number of bones per vertex to include// Returns:		void///////////////////////////////////////////////////////////////////////////////void COGLView::AutoComputeWeights(int maxBonesPerVertex){/// Local Variables ///////////////////////////////////////////////////////////	t_VWeight *tempWeight;	float maxWeight, weight, dist;	tVector vDist;///////////////////////////////////////////////////////////////////////////////	if (m_Skeleton && m_CurBone)	{		tempWeight = (t_VWeight *)malloc(sizeof(t_VWeight) * m_Skeleton_BoneCnt);		// Go through all the vertices in the model		for (int vertexNum = 0; vertexNum < m_Model.vertexCnt; vertexNum++)		{			// Go through each bone			for (int i = 0; i < m_Skeleton_BoneCnt; i++)			{				// Get effector position in world space				tVector boneRoot(m_Skeleton[i].transMatrix.m[12],m_Skeleton[i].transMatrix.m[13],m_Skeleton[i].transMatrix.m[14]);				// if this is an end effector just check distance				if (m_Skeleton[i].childCnt == 0)				{					VectorDifference(&boneRoot, &m_Model.vertex[vertexNum],&vDist);					dist = VectorLength(&vDist);				}				else				{					// Get child effector position in world space					tVector boneChild(m_Skeleton[i].children[0]->transMatrix.m[12],m_Skeleton[i].children[0]->transMatrix.m[13],m_Skeleton[i].children[0]->transMatrix.m[14]);					VectorDifference(&boneChild, &boneRoot,&vDist);					ScaleVector(&vDist,0.75f,&vDist);					VectorSum(&boneRoot,&vDist,&boneChild);					dist = DistToBone(&boneRoot,&boneChild, &m_Model.vertex[vertexNum]);				}				// 1 / distance ^ 4				weight = 1.0f / (dist * dist * dist * dist);				tempWeight[i].vertex = i;				tempWeight[i].weight = weight * m_Skeleton[i].bsphere;			}			// Sort the weights so that they are in weight order			qsort(tempWeight,m_Skeleton_BoneCnt, sizeof(t_VWeight),CompareWeights);			// Zero out any extras			for (i = maxBonesPerVertex; i < m_Skeleton_BoneCnt; i++)			{				tempWeight[i].weight = 0.0f;			}			// Go through each bone and set the final weights			for (i = 0; i < m_Skeleton_BoneCnt; i++)			{				m_Skeleton[tempWeight[i].vertex].CV_weight[vertexNum].weight = tempWeight[i].weight;				m_Skeleton[tempWeight[i].vertex].CV_weight[vertexNum].vertex = vertexNum;			}		}		free(tempWeight);		// Go through all the vertices in the model		for (vertexNum = 0; vertexNum < m_Model.vertexCnt; vertexNum++)		{			maxWeight = 0.0f;			// Go through each bone to get max weight			for (int i = 0; i < m_Skeleton_BoneCnt; i++)			{				maxWeight += m_Skeleton[i].CV_weight[vertexNum].weight;			}			// Normalize the weights so they all add to 1 for this bone			if (maxWeight > 0.0f)			{				for (i = 0; i < m_Skeleton_BoneCnt; i++)				{					m_Skeleton[i].CV_weight[vertexNum].weight = m_Skeleton[i].CV_weight[vertexNum].weight / maxWeight;				}			}		}	}}