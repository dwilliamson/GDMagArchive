#include <curves/bezier/BezierBasis.h>

template< class T >
BezierBasis< T >::BezierBasis() : Polynomial< T >()
{
}
  
template< class T >
BezierBasis< T >::BezierBasis( const BezierBasis& source ) : Polynomial< T >( source )
{
}

// This creates basis i out of n+1 bases, where i is [0,n] (so BezierBasis(3,5) would mean
// that this was the 4th basis in a curve with 6 control points.
template< class T >
BezierBasis< T >::BezierBasis( int i, int n )
{
  // A bezier basis function is:
  //
  //   ______n!_____   (  i        (n-i) )
  //    i! * (n-i)!  * ( t  * (1-t)      )
  //
  // Where n is one less than the number of control points and i is the current point (from 0 to n).
  // We use Polynomial to make it easier to reduce this function to a general form polynomial.

  // Generate those binomial coefficients (the factorial part of the equation).
  std::vector< int > binomialCoeffs;
  int funcScalar = calculateBinomial( n + 1, i );

  // Now fScalar's the ( n! / (i! * (n-i)! ) ) part.
  
  // Now this polynomial is just the constant 1.
  std::vector< T > coeffs;
  coeffs.push_back( 1 );
  Polynomial< T > tToI;
  tToI.setCoefficients( coeffs );
  
  // ... and this polynomial is t^1.
  coeffs.clear();
  coeffs.push_back( 0 );
  coeffs.push_back( 1 );
  Polynomial< T > polyT;
  polyT.setCoefficients( coeffs );
  
  // Now multiply tToI by t^1, i times, and tToI becomes t^i.
  for ( int lcv = 0; lcv < i; lcv++ )
  {
    tToI *= polyT;
  }
  
  // Now we just have to get (1-t)^(n-i)
  
  // This polynomial is just the constant 1.
  coeffs.clear();
  coeffs.push_back( 1 );
  Polynomial< T > oneMinusT;
  oneMinusT.setCoefficients( coeffs );
  
  // ... and this polynomial is 1-t.
  coeffs.clear();
  coeffs.push_back( 1 );
  coeffs.push_back( -1 );
  Polynomial< T > polyOneMinusT;
  polyOneMinusT.setCoefficients( coeffs );
  
  // Now multiply oneMinusT by polyOneMinusT n-i times, and it'll be (1-t)^(n-i).  How about that.
  for ( lcv = 0; lcv < n-i; lcv++ )
  {
    oneMinusT *= polyOneMinusT;
  }
  
  // Okay, we've got fScalar, tToI, and oneMinusT.  Multiply them together, and that's our basis.
  static_cast< Polynomial< T >& >( *this ) = tToI;
  static_cast< Polynomial< T >& >( *this ) *= oneMinusT;
  static_cast< Polynomial< T >& >( *this ) *= funcScalar;
}

template< class T >
int BezierBasis< T >::calculateBinomial( int row, int col )
{
  std::vector< int > row1;
  std::vector< int > row2;
  
  std::vector< int >* curRow = &row1;
  std::vector< int >* nextRow = &row2;
  
  // This is the first row of Pascal's triangle (tricky, huh?)
  row1.push_back( 1 );
  
  int curRowNum;
  
  // For each row until we hit our target, calculate the next row and advance.
  for( curRowNum = 1; curRowNum < row; curRowNum++ )
  {
    // Wipe the next row.
    nextRow->clear();

    // We know the row starts with a 1, and that can't be generated by two elements from
    // the previous row, so just push it back.
    nextRow->push_back( 1 );

    // For each column, generate it from the two above it (if there are two.)
    for ( int col = 0; col < curRow->size() - 1; col++ )
    {
      nextRow->push_back( (*curRow)[ col ] + (*curRow)[ col+1 ] );
    }

    // This is the ending of every row: another 1.  Just like the beginning.
    nextRow->push_back( 1 );

    // Now swap pointers so our "next" row becomes the current one, and generate yet another row.
    std::vector< int >* swap = curRow;
    curRow = nextRow;
    nextRow = swap;
  }

  // Because we swap at the end of the loop, curRow now holds the correct result.
  return (*curRow)[ col ];
}

// This is used in normal generation.
template< class T >
BezierBasis< T >& BezierBasis< T >::differentiate()
{
  Polynomial< T >::differentiate();
  return *this;
}
