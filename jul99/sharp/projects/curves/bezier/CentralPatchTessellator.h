#ifndef CENTRALPATCHTESSELLATOR_H
#define CENTRALPATCHTESSELLATOR_H

#include <curves/bezier/BezierPatchTessellator.h>

struct PatchPoint;

class CentralPatchTessellator : public BezierPatchTessellator
{
public:
  CentralPatchTessellator();
  CentralPatchTessellator( const CentralPatchTessellator& );
  CentralPatchTessellator& operator=( const CentralPatchTessellator& );

  ~CentralPatchTessellator();

  // This creates the triangle mesh representing the patch with the supplied information.
  // After calling tessellate, draw() can be called to draw the triangle mesh via OpenGL.
  virtual void tessellate( const std::vector< std::vector< CurvePoint > >&, 
                           const std::vector< BasisFunction >&, 
                           const std::vector< BasisFunction >& ) const;

  // This draws the mesh (generated by tessellate()) using OpenGL vertex and texture coordinate
  // arrays (compiled if the extension exists), and either using two-texture multitexture or
  // a single pass if multitexture is not enabled (so if there's no multitexture, you need to call
  // draw() twice and set up the blending correctly yourself).
  virtual void draw(bool multitexture = true) const;

  // The granularity determines the threshold of recursion for the tessellation.  A higher granularity
  // makes for a lower-triangle tessellation.  The initial value is 1.0f.
  virtual void setGranularity( float newVal );

  // This sets the maximum tessellation depth for the patch.  It allocates an array of indices
  // of size newVal x newVal.
  virtual void setMaxDepth( int newVal ) const;

  // These are helper functions that just calculate the indices for the corners of the patch --
  // because we store the information in a one-dimensional array, it's a bit of work to find.
  int getMinXMinYIndex() const;
  int getMinXMaxYIndex() const;
  int getMaxXMinYIndex() const;
  int getMaxXMaxYIndex() const;

  // This returns the dimension of our arrays, which is the maximum level of tessellation we can do.
  // If it's N, that means that at maximum tessellation, the patch will be an NxN triangle grid.
  int getNumEdgeVerts() const;

  // This compares the tessellation levels along the edge of this patch and the other argument patch
  // where the edges are defined by the argument x and y values, and does the collapses necessary to
  // eliminate any cracking between the patches along that edge.
  void fixInterPatchCracks(int x0, int y0, int x1, int y1, 
                           int x0That, int y0That, int x1That, int y1That,
                           const CentralPatchTessellator* that) const;

  // This fixes internal cracks in this patch, using the argument indices as corners of a subpatch to
  // recurse on (so, to start it going, call it with the patch's four corners as the arguments).
  void fixCracks( int, int, int, int ) const;

protected:
  void tessellateSubPatch( int, int, int, int, float delta, int depth ) const;

  void drawPatch( int, int, int, int ) const;

  // This adds another vertex to actualVerts and returns its index.
  int addNewVertex() const;

  // This makes sure that at least n vertices are available before reallocation will occur.
  void reserveVerts(int n) const;

  float threshold;

  mutable int* vertices;
  mutable int numEdgeVerts;
  mutable bool attemptMultitexture;

  // We store indices in <vertices> that point to these things to reduce memory overhead.
  // The actualVerts store the information needed in processing, whereas the actualPoints
  // and actualTexCoords just store linear arrays of floats (each 3 floats in actualPoints is
  // a point, each 2 floats in actualTexCoords is a texture coordinate).  Using this approach,
  // we can just hand actualPoints and actualTexCoords to OpenGL as vertex and texture coordinate
  // arrays and then even use the compiled vertex array extension to speed things up.  These 
  // arrays are maintained by addNewVertex and reserveVerts which double the arrays' size when
  // more room is needed.
  mutable PatchPoint* actualVerts;
  mutable float* actualPoints;
  mutable float* actualTexCoords;

  // These monitor our arrays.  The capacity is how much space we have, the index is how much
  // space we've used.  When the index is the capacity and they ask for another, we have to
  // reallocate and copy.
  mutable int vertCapacity;
  mutable int vertIndex;

  // These are used for recursion checking and help determine whether the surface is curved
  // enough when drawn to merit more tessellation.
  mutable CurvePoint cameraPos;
  mutable float tanHalfFov;
};

#endif //CENTRALPATCHTESSELLATOR_H